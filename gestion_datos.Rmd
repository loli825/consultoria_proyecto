---
title: "Arreglos csv"
author: "Manuela Lopez Cambron, 1673688"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
df <- read.csv("prado.csv", fileEncoding = "UTF-8")
```

# GESTIÓN DE DATOS

## Manejo de valores faltantes

Tal y como se ha generado la base de datos, los valores faltantes estan indicados como "0". Veamos el porcentaje de estos para cada variables:
```{r}
# FRECUENCIA DE VARIABLES
prop_cero <- sapply(df, function(x) mean(as.character(x) == "0"))

prop_cero_lista <- data.frame(
  variable  = names(df),
  prop_cero = as.numeric(prop_cero),
  row.names = NULL
)

# ordenar de mayor a menor
prop_cero_lista <- prop_cero_lista[order(prop_cero_lista$prop_cero, decreasing = TRUE), ]

prop_cero_lista
```

Eliminamos "estado", "lugar_produccion" y "materia", debido a su gran presencia de valores faltantes no podemos extraer información. Eliminamos también los casos donde haya ausencia de información para las variable "procedencia", "soporte" o "tecnica". Justificamos el análisis de casos completos considerando esta ausencia totalmente aleatoria provocada por fenomenos sociales o históricos a cerca de la conservaciónd de estas obras que no mantienen relación con nuestro objetivo, la proporción aurea.

Los valores faltantes de las otras variables se manejaran automaticamente mediante las transformaciones pertinentes de estas en la siguiente sección.

**Eliminar variables no deseadas**
```{r}
# ELIMINAR VARIABLES CON BAJA FREC.
df <- df[ , !(names(df) %in% c("estado", "lugar_produccion", "materia")) ]
names(df)
```

**Eliminamos casos incompletos**
```{r}
# ELIMINAR CASOS INCOMPLETOS
n_antes <- nrow(df)
df <- df[df$tecnica != "0",]; df <- df[df$soporte != "0",]

n_despues <- nrow(df)
cat("Se han eliminado", n_antes-n_despues, "casos")
```

## Transformación de variables

Aunque nuestra base de datos ya aporta la información necesaria, sus variables no presentan la estructura que necesitamos para trabajarla. Por esta razón, en esta sección se procederá a transformar y crear nuevas variables de manera que queden listas para ser utilizadas en el modelaje.

**Recodificación de variables de autoría**

Agruparemos las variables "autor", autora", "autores" creando una variable "tipo_autor" que indicará si se trata de 'hombre/mujer/varios/anonimo' y además se conservarán los nombres en una nueva variable llamada "nombre_autor". 
```{r}
# RECOD. 'AUTOR', 'AUTORA', 'AUTORES'
# 1) nombre_autor: coger el valor distinto de "0"
df$nombre_autor <- ifelse(df$autor != "0", df$autor,
                   ifelse(df$autora != "0", df$autora,
                   ifelse(df$autores != "0", df$autores, "0")))

# 2) tipo_autor: segun valor distinto de "0"
df$tipo_autor <- ifelse(df$autor == "Anónimo", "anonimo",
                 ifelse(df$autora  != "0", "mujer",
                 ifelse(df$autores != "0", "varios",
                 ifelse(df$autor   != "0", "hombre", "0"))))
df$tipo_autor <- as.factor(df$tipo_autor)

# 3) eliminamos variables antiguas
df$autor <- NULL
df$autora <- NULL
df$autores <- NULL

# comprobacion 
table(df$tipo_autor)
head(df[, c("tipo_autor","nombre_autor")], 10)
tail(df[, c("tipo_autor","nombre_autor")], 10)
```

**Recodificación de variable "serie"**

Consideramos apropiado mantener "serie" en calidad de conocer si la pintura pertenece (1) o no (0) a una serie, sin importar a cuál, por lo que la convertiremos en una variable binaria indicadora. 
```{r}
# RECOD. 'SERIE'
df$serie <- ifelse(df$serie == "0", 0, 1)
df$serie <- as.factor(df$serie)

table(df$serie)
```

**Recodificación de variable "tecnica"**

Estamos frente a una variable que podría ser interpretada como un factor pero presenta demasiados niveles.
```{r}
cat("Niveles de 'tecnica':\n")
table(df$tecnica)
```

La solución óptima, dado que muchos casos presentan niveles multi-etiqueta, será recodificar en varias variables dummies como indicadores interpretables de la presencia de cada categoría. De esta manera podremos asociar la presencia de cada técnica concreta con el aumento o no en la probabilidad de observar nuestro evento de interés. Obviamos las técnicas poco frecuentes 'Pastillaje', 'Pastel', 'Aguada', 'Técnicas de fotografía'
```{r}
# RECOD. 'TECNICA'
mk <- function(x, pattern) as.integer(grepl(pattern, x, ignore.case = TRUE))

## normalizar
df$tecnica <- trimws(as.character(df$tecnica))
x <- df$tecnica

## dummies 
df$tec_oleo       <- mk(x, "Óleo")
df$tec_temple     <- mk(x, "Temple")     
df$tec_tempera    <- mk(x, "Témpera")
df$tec_fresco     <- mk(x, "Pintura al fresco|falso fresco|al seco")
df$tec_mixta      <- mk(x, "Técnica mixta")
df$tec_enconchado <- mk(x, "Enconchado")
df$tec_grisalla   <- mk(x, "Grisalla")
df$tec_dorado     <- mk(x, "Dorado|pan de oro")
df$tec_pastillaje = mk(x,"Pastillaje")
df$tec_pastel = mk(x,"Pastel")
df$tec_aguada = mk(x,"Aguada")
df$tec_foto = mk(x,"Técnicas de fotografía")

tec_cols <- c("tec_oleo","tec_temple","tec_tempera","tec_fresco","tec_mixta", "tec_enconchado","tec_grisalla","tec_dorado", "tec_pastillaje", "tec_pastel", "tec_aguada", "tec_foto")

## frecuencias/comprobación
cat("Frecuencia de cada técnica:\n")
print(sort(colSums(df[, tec_cols, drop=FALSE]), decreasing = TRUE))
```

Vemos que hay una serie de técnicas con poca frecuencia, por el bien de nuestros futuros modelos, agruparemos estas variables dummies en una nueva llamada "tec_otras". La única con baja frecuencia que conservaremos será 'fresco' debido a su posible efecto sobre la respuesta, ja que envuelve un tipo de obra con características propias. También unificaremos 'temple', 'tempera' y 'aguada' en "tec_acuosas" por sus características similares.
```{r}
df$tec_acuosas <- as.integer(
  df$tec_temple == 1 |
  df$tec_tempera == 1 |
  df$tec_aguada == 1
)

df$tec_otras <- as.integer(
  df$tec_dorado == 1 |
  df$tec_enconchado == 1 |
  df$tec_grisalla == 1 |
  df$tec_pastillaje == 1 |
  df$tec_pastel == 1 |
  df$tec_foto == 1
)

tec_cols <- c("tec_oleo", "tec_acuosas", "tec_mixta", "tec_fresco", "tec_otras")

df <- df[, c(setdiff(names(df), grep("^tec_", names(df), value = TRUE)), tec_cols)]

cat("Frecuencia de cada técnica:\n")
print(sort(colSums(df[, tec_cols, drop=FALSE]), decreasing = TRUE))
```

A continuación proporcionamos un listado de los niveles originales y que dummies activa cada uno:
```{r}
lab <- sub("^tec_", "", tec_cols)

dic_tec <- aggregate(df[, tec_cols], list(tecnica = df$tecnica), max)

dic_tec$activas <- apply(dic_tec[, tec_cols], 1, function(z) {
  paste(lab[z == 1], collapse = ", ")
})

dic_tec <- dic_tec[, c("tecnica", "activas")]
dic_tec

#convertimos a factor 
# df[tec_cols] <- lapply(df[tec_cols], as.factor)
```

Para confirmar si el tipod e codificación muultietiqueta con dummies es útil o no vamos a detectar cuantas observacines hacen uso de tal carácter contando cuantas ativan más de 1 dummy:
```{r}
n_tec <- rowSums(df[tec_cols] == 1)
n_multietiqueta <- sum(n_tec > 1)

n_multietiqueta
```

Vemos que el porcentaje de observaciones que activan más una técnica (después de nuetsra reagrupación de estas) es obviamente despreciable. Por esta razón y con el objetivo de simplificar nuestra base de datos, procedemos a reestablecer un único factor indicativo de la técnica utilizada, con los actuales valores de las dummies, y clasificaremos estas observaciones multietiqueta dentro de la categoria 'tec_mixta'.
```{r}
# contar cuantas tecnicas activas por fila
n_tec <- rowSums(df[tec_cols] == 1)

# nueva columna
df$tecnica <- NA_character_

# multietiqueta a 'mixta'
df$tecnica[n_tec > 1] <- "mixta"

# niveles según dummy
idx_single <- which(n_tec == 1)

if (length(idx_single) > 0) {
  M <- df[idx_single, tec_cols, drop = FALSE] == 1
  active_col <- tec_cols[max.col(M, ties.method = "first")]
  df$tecnica[idx_single] <- sub("^tec_", "", active_col) # nombre arreglado
}

#comprobación
sort(table(df$tecnica), decreasing = TRUE)
```

**Recodificación de variable "soporte"**

Esta variable presenta el mismo problema de exceso de niveles.
```{r}
cat("\nNiveles de 'soporte':\n") 
table(df$soporte)
```

En el caso de "soporte" vemos que son escasas las observaciones en que aparecen etiquetas multi-nivel, además es lógico interpretar que existe un soporte principal (aunque haya variaciones como montajes o transferencias), por lo que el sentido natural es comparar tipos de soporte y no su presencia. En consecuencia, transformaremos esta variable en un solo factor llamado "soporte_grp" agrupando sus niveles en un conjunto más reducido y de categorías más generales y proporcionando un nivel llamado 'ambiguo' para manejar aquellos niveles de soporte multi-etiqueta donde no se puede determinar el soporte principal. También se agregará una variable binaria llamada 'sop_montaje' para indicar si se trata de un soporte puro (0) o de un montaje (1), de esta manera podremos conservar información sobre este aspecto material relevante sin multiplicar categorías.
```{r}
# RECOD. 'SOPORTE'
## normaliza
df$soporte <- trimws(as.character(df$soporte))
s <- df$soporte

## dummy montaje
df$sop_montaje <- as.integer(
  grepl(";", s, fixed = TRUE) |
  grepl("sobre|pegado|pasad[oa]|trasladad[oa]", s, ignore.case = TRUE)
)

g <- rep(NA_character_, length(s))

# 1) Multi-etiqueta
g[grepl(";", s, fixed = TRUE)] <- "Ambiguo"

# 2) Mural
g[is.na(g) & grepl("Revestimiento mural", s, ignore.case = TRUE)] <- "Mural"

# 3) Clave para clasificar:
#    - "pasado/a" o "trasladado/a": conservar soporte inicial
#    - "sobre" o "pegado en/a": conservar superficie
k <- s
idx <- is.na(g)

k[idx] <- sub("\\s+(pasad[oa]|trasladad[oa]).*$", "", k[idx], ignore.case = TRUE)
k[idx] <- sub("\\s+sobre\\s+.*$", "", k[idx], ignore.case = TRUE)
k[idx] <- sub("\\s+pegad[oa]\\s+(en|a)\\s+.*$", "", k[idx], ignore.case = TRUE)
k[idx] <- trimws(k[idx])

# 4) Clasificación (sobre k)
g[is.na(g) & grepl("Piedra|Pizarra", k, ignore.case = TRUE)] <- "Piedra/Pizarra"
g[is.na(g) & grepl("cobre|Hojalata", k, ignore.case = TRUE)] <- "Metal"
g[is.na(g) & grepl("Papel|Vitela", k, ignore.case = TRUE)] <- "Papel/Vitela"
g[is.na(g) & grepl("Cartón|Cartulina", k, ignore.case = TRUE)] <- "Cartón/Cartulina"
g[is.na(g) & grepl("Tabla|Táblex|Contrachapado", k, ignore.case = TRUE)] <- "Tabla/Panel"
g[is.na(g) & grepl("Lienzo", k, ignore.case = TRUE)] <- "Lienzo"
g[is.na(g) & grepl("Sarga|Raso", k, ignore.case = TRUE)] <- "Lienzo"  # <-- CAMBIO AQUÍ
g[is.na(g) & grepl("Corcho", k, ignore.case = TRUE)] <- "Corcho"

df$soporte_grp <- factor(
  g,
  levels = c("Lienzo","Tabla/Panel","Metal","Papel/Vitela","Cartón/Cartulina",
             "Mural","Piedra/Pizarra","Corcho","Ambiguo")
)

## frequencias/comprobación
head(df[, c("soporte", "soporte_grp", "sop_montaje")])

cat("Frecuencia de cada soporte:\n")
sort(table(df$soporte_grp), decreasing = TRUE)

cat("Frecuencia de cada soporte puro/montaje:\n")
with(df, table(soporte_grp, sop_montaje))
```

Debido a la baja frecuencia observada en algunas clases, deberiamos vovler a reagrupar estas minoritarias en un mismo grupo. Decidimos conservar 'mural' y 'papel/vileta' como últimos de frecuencia aceptable y devido a su potencial efecto sobre la respesta. Reagrupamos el resto en un nivel llamadp 'otros'.
```{r}
tmp <- as.character(df$soporte_grp)

tmp[tmp %in% c("Cartón/Cartulina", "Ambiguo", "Piedra/Pizarra", "Corcho")] <- "Otros"

df$soporte_grp <- factor(
  tmp,
  levels = c("Lienzo", "Tabla/Panel", "Metal", "Mural", "Papel/Vitela", "Otros")
)

sort(table(df$soporte_grp), decreasing = TRUE)
```

A continuación proporcionamos un listado con los niveles originales y a que nuevo nivel han sido asignados:
```{r}
dic_sop <- aggregate(
  df[, c("sop_montaje")],
  by = list(soporte = df$soporte, soporte_grp = df$soporte_grp),
  FUN = max
)
 names(dic_sop) <- c("soporte", "soporte_grp", "sop_montaje")
dic_sop

# convertimos a factor
df$sop_montaje <- as.factor(df$sop_montaje)
```


**Recodificación de variable "fecha"**

La datación de las pinturas es muy inexacta y provoca que tengamos fechas de muschos formatos distintos. La complejidad de esta avriable escapa a nuestras posibilidades pero pensamos que es realmente valiosa, por lo que hemos recurrido a insteligencias artificiales para generar el codigo a continuación que nos permita reexplicar la información de la siguiente manera:
```{r}
# --- Utilidades ---
clean_fecha <- function(s) {
  s <- trimws(s)
  s <- gsub("<[^>]+>", " ", s, perl = TRUE)              # quita HTML
  s <- gsub("\u2013|\u2014", "-", s, perl = TRUE)        # – —
  s <- gsub("\\s+", " ", s, perl = TRUE)                # espacios múltiples
  trimws(s)
}

roman_to_int <- function(r) {
  r <- toupper(r)
  vals <- c(I=1, V=5, X=10, L=50, C=100, D=500, M=1000)
  chars <- strsplit(r, "")[[1]]
  total <- 0
  prev <- 0
  for (ch in rev(chars)) {
    v <- vals[ch]
    if (is.na(v)) return(NA_integer_)
    if (v < prev) total <- total - v else { total <- total + v; prev <- v }
  }
  as.integer(total)
}

century_bounds <- function(cent) {
  # Siglo XVII => 1601..1700 (convención estándar)
  c((cent - 1) * 100 + 1, cent * 100)
}

detect_part <- function(txt) {
  # Normaliza acentos para detectar "último/ultimo", "después/despues", etc.
  t <- tolower(iconv(txt, from = "UTF-8", to = "ASCII//TRANSLIT"))
  
  if (grepl("primer\\s+cuarto",  t, perl=TRUE)) return("1_cuarto")
  if (grepl("segundo\\s+cuarto", t, perl=TRUE)) return("2_cuarto")
  if (grepl("tercer\\s+cuarto",  t, perl=TRUE)) return("3_cuarto")
  if (grepl("ultimo\\s+cuarto",  t, perl=TRUE)) return("4_cuarto")
  
  if (grepl("primer\\s+tercio",  t, perl=TRUE)) return("1_tercio")
  if (grepl("segundo\\s+tercio", t, perl=TRUE)) return("2_tercio")
  if (grepl("ultimo\\s+tercio",  t, perl=TRUE)) return("3_tercio")
  
  if (grepl("primera\\s+mitad",  t, perl=TRUE)) return("primera_mitad")
  if (grepl("segunda\\s+mitad",  t, perl=TRUE)) return("segunda_mitad")
  
  if (grepl("principio", t, perl=TRUE)) return("principio")
  if (grepl("mediados",  t, perl=TRUE)) return("mediados")
  if (grepl("finales",   t, perl=TRUE)) return("finales")
  
  "whole"
}

interval_century_part <- function(cent, part) {
  b <- century_bounds(cent)
  start <- b[1]
  # trabajamos con offsets 0..99 dentro del siglo
  add <- function(a, z) c(start + a, start + z)
  
  if (part == "whole") return(c(b[1], b[2]))
  
  if (part == "principio")     return(add(0, 19))
  if (part == "mediados")      return(add(40, 59))
  if (part == "finales")       return(add(80, 99))
  if (part == "primera_mitad") return(add(0, 49))
  if (part == "segunda_mitad") return(add(50, 99))
  
  if (part %in% c("1_cuarto","2_cuarto","3_cuarto","4_cuarto")) {
    q <- as.integer(sub("_cuarto","",part))
    return(add((q-1)*25, q*25 - 1))
  }
  
  if (part %in% c("1_tercio","2_tercio","3_tercio")) {
    t <- as.integer(sub("_tercio","",part))
    offs <- list(c(0,32), c(33,65), c(66,99))
    return(add(offs[[t]][1], offs[[t]][2]))
  }
  
  c(b[1], b[2])
}

extract_years <- function(txt, max_year = 2100L) {
  m <- gregexpr("(?<!\\d)(\\d{3,4})(?!\\d)", txt, perl = TRUE)
  y <- regmatches(txt, m)[[1]]
  if (length(y) == 0) return(integer(0))
  y <- as.integer(y)
  y <- y[y >= 1000 & y <= max_year]
  y
}

# --- Parser principal ---
parse_fecha_one <- function(s) {
  s <- clean_fecha(s)
  s_ascii <- tolower(iconv(s, from="UTF-8", to="ASCII//TRANSLIT"))
  
  # Flag de incertidumbre (?", ca., hacia, paréntesis con alternativas, etc.)
  incierta <- grepl("\\?", s, perl=TRUE) || grepl("\\bca\\b", s_ascii, perl=TRUE) || grepl("\\bhacia\\b", s_ascii, perl=TRUE)
  
  # Caso "compuesto" por ';' (pocas filas, pero existe)
  if (grepl(";", s, fixed = TRUE)) {
    parts <- trimws(strsplit(s, ";", fixed = TRUE)[[1]])
    parsed <- lapply(parts, parse_fecha_one)
    
    starts <- sapply(parsed, function(x) x$start)
    ends   <- sapply(parsed, function(x) x$end)
    
    start <- suppressWarnings(min(starts, na.rm = TRUE))
    end   <- suppressWarnings(max(ends, na.rm = TRUE))
    if (!is.finite(start)) start <- NA_integer_
    if (!is.finite(end))   end   <- NA_integer_
    
    return(list(
      start = as.integer(start), end = as.integer(end),
      tipo = "multi",
      incierta = TRUE,
      abierta_inicio = is.na(start),
      abierta_fin = is.na(end)
    ))
  }
  
  # Separa "main" y paréntesis (para evitar años bibliográficos en notas)
  main <- trimws(sub("\\s*\\(.*$", "", s, perl=TRUE))
  par  <- ""
  if (grepl("\\(", s, perl=TRUE) && grepl("\\)", s, perl=TRUE)) {
    par <- sub("^.*\\((.*)\\)\\s*$", "\\1", s, perl=TRUE)
  }
  
  main_ascii <- tolower(iconv(main, from="UTF-8", to="ASCII//TRANSLIT"))
  
  # 1) Año exacto
  if (grepl("^\\d{3,4}$", main_ascii, perl=TRUE)) {
    y <- as.integer(main_ascii)
    start <- y; end <- y; tipo <- "year_exact"
  } else {
    # 2) Rango de años
    m <- regexec("^(\\d{3,4})\\s*-\\s*(\\d{3,4})$", main_ascii, perl=TRUE)
    g <- regmatches(main_ascii, m)[[1]]
    if (length(g) == 3) {
      a <- as.integer(g[2]); b <- as.integer(g[3])
      start <- min(a,b); end <- max(a,b); tipo <- "year_range"
    } else {
      # 3) Hacia (aprox)
      m <- regexec("^hacia\\s+(\\d{3,4})$", main_ascii, perl=TRUE)
      g <- regmatches(main_ascii, m)[[1]]
      if (length(g) == 2) {
        y <- as.integer(g[2])
        start <- y; end <- y; tipo <- "circa"
      } else {
        # 4) Antes de / Después de
        m <- regexec("^antes\\s+de\\s+(\\d{3,4})$", main_ascii, perl=TRUE)
        g <- regmatches(main_ascii, m)[[1]]
        if (length(g) == 2) {
          y <- as.integer(g[2])
          start <- NA_integer_; end <- y - 1L; tipo <- "before"
        } else {
          m <- regexec("^despues\\s+de\\s+(\\d{3,4})$", main_ascii, perl=TRUE)
          g <- regmatches(main_ascii, m)[[1]]
          if (length(g) == 2) {
            y <- as.integer(g[2])
            start <- y + 1L; end <- NA_integer_; tipo <- "after"
          } else {
            # 5) Siglo completo: "Siglo XVII"
            m <- regexec("^siglo\\s+([ivxlcdm]+)$", main_ascii, perl=TRUE)
            g <- regmatches(main_ascii, m)[[1]]
            if (length(g) == 2) {
              cent <- roman_to_int(g[2])
              b <- century_bounds(cent)
              start <- b[1]; end <- b[2]; tipo <- "century"
            } else {
              # 6) Rango de siglos: "Siglos XV - XVI"
              m <- regexec("^siglos\\s+([ivxlcdm]+)\\s*-\\s*([ivxlcdm]+)$", main_ascii, perl=TRUE)
              g <- regmatches(main_ascii, m)[[1]]
              if (length(g) == 3) {
                c1 <- roman_to_int(g[2]); c2 <- roman_to_int(g[3])
                lo <- min(c1,c2); hi <- max(c1,c2)
                b1 <- century_bounds(lo); b2 <- century_bounds(hi)
                start <- b1[1]; end <- b2[2]; tipo <- "century_range"
              } else {
                # 7) Rango con partes de siglo: "Finales del siglo XVI - Principio del siglo XVII"
                m <- regexec("^(.*)\\s+del\\s+siglo\\s+([ivxlcdm]+)\\s*-\\s*(.*)\\s+del\\s+siglo\\s+([ivxlcdm]+)$",
                             main_ascii, perl=TRUE)
                g <- regmatches(main_ascii, m)[[1]]
                if (length(g) == 5) {
                  p1 <- detect_part(g[2]); c1 <- roman_to_int(g[3])
                  p2 <- detect_part(g[4]); c2 <- roman_to_int(g[5])
                  i1 <- interval_century_part(c1, p1)
                  i2 <- interval_century_part(c2, p2)
                  start <- min(i1[1], i2[1]); end <- max(i1[2], i2[2])
                  tipo <- "century_part_range"
                } else {
                  # 8) Parte de siglo: "Primer tercio del siglo XVII", "Finales del siglo XVI", etc.
                  m <- regexec("^(.*)\\s+del\\s+siglo\\s+([ivxlcdm]+)$", main_ascii, perl=TRUE)
                  g <- regmatches(main_ascii, m)[[1]]
                  if (length(g) == 3) {
                    part <- detect_part(g[2])
                    cent <- roman_to_int(g[3])
                    i <- interval_century_part(cent, part)
                    start <- i[1]; end <- i[2]; tipo <- "century_part"
                  } else {
                    # 9) Fallback: extraer años sueltos del "main"
                    yrs <- extract_years(main_ascii, max_year = 2100L)
                    if (length(yrs) > 0) {
                      start <- min(yrs); end <- max(yrs); tipo <- "fallback"
                      incierta <- TRUE
                    } else {
                      start <- NA_integer_; end <- NA_integer_; tipo <- "unparsed"
                      incierta <- TRUE
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  # Extensión opcional usando años en paréntesis SOLO si están cerca del intervalo principal
  if (nzchar(par) && !is.na(start) && !is.na(end)) {
    yrs_par <- extract_years(tolower(iconv(par, "UTF-8", "ASCII//TRANSLIT")), max_year = 2100L)
    if (length(yrs_par) > 0) {
      lo <- min(yrs_par); hi <- max(yrs_par)
      if (lo >= (start - 50L) && hi <= (end + 50L)) {
        start <- min(start, lo); end <- max(end, hi)
        incierta <- TRUE
      }
    }
  }
  
  list(
    start = as.integer(start),
    end = as.integer(end),
    tipo = tipo,
    incierta = as.logical(incierta),
    abierta_inicio = is.na(start),
    abierta_fin = is.na(end)
  )
}

# --- Aplicar a todo el dataset ---
n <- nrow(df)
fecha_inicio <- integer(n); fecha_fin <- integer(n)
fecha_tipo <- character(n)
fecha_incierta <- logical(n)
fecha_abierta_inicio <- logical(n)
fecha_abierta_fin <- logical(n)

for (i in seq_len(n)) {
  p <- parse_fecha_one(df$fecha[i])
  fecha_inicio[i] <- ifelse(is.na(p$start), NA_integer_, p$start)
  fecha_fin[i]    <- ifelse(is.na(p$end),   NA_integer_, p$end)
  fecha_tipo[i] <- p$tipo
  fecha_incierta[i] <- p$incierta
  fecha_abierta_inicio[i] <- p$abierta_inicio
  fecha_abierta_fin[i] <- p$abierta_fin
}

# Relleno de intervalos abiertos con mínimo/máximo observados (para evitar NA en modelos)
minY <- min(fecha_inicio[!is.na(fecha_inicio)], na.rm = TRUE)
maxY <- max(fecha_fin[!is.na(fecha_fin)], na.rm = TRUE)

fecha_inicio2 <- ifelse(is.na(fecha_inicio), minY, fecha_inicio)
fecha_fin2    <- ifelse(is.na(fecha_fin),    maxY, fecha_fin)

fecha_est <- as.integer(round((fecha_inicio2 + fecha_fin2) / 2))
fecha_ancho    <- as.integer(fecha_fin2 - fecha_inicio2)

# Añadir al data.frame
df$fecha_inicio <- as.integer(fecha_inicio2)
df$fecha_fin <- as.integer(fecha_fin2)
df$fecha_tipo <- fecha_tipo
df$fecha_incierta <- fecha_incierta
df$fecha_abierta_inicio <- fecha_abierta_inicio
df$fecha_abierta_fin <- fecha_abierta_fin
df$fecha_est <- fecha_est
df$fecha_ancho <- fecha_ancho

# --- Comprobaciones rápidas ---
print(head(df[, c("fecha", "fecha_tipo", "fecha_inicio", "fecha_fin", "fecha_est", "fecha_ancho")], 12))

df[c(1,100,200,300,400,500,600,700,800,900), c("fecha", "fecha_tipo", "fecha_inicio", "fecha_fin", "fecha_est", "fecha_ancho")]
```

Ahora con estas nuevas variables podemos tomar una decisión teniendo en cuenta nuestras necesidades y el posterior modelaje. Nos decantamos por mantener las variables "fecha" original, como información de posible interés futuro, "anio_est" como una aproximación y "fecha_ancho" que nos permitirá almacenar ifnormación sobre la anterior aproximación, ya que en muchos casos contiene mucha variabilidad. Utilizando estas dos últimas variables en un modelo podremos hacer que este no interprete como iguales observaciones que comparten el año estimado si su rango es distinto.
```{r}
df$fecha_inicio <- NULL
df$fecha_fin <- NULL
df$fecha_tipo <- NULL
df$fecha_incierta <- NULL
df$fecha_abierta_inicio <- NULL
df$fecha_abierta_fin <- NULL
```

Echamos un primer vistazo a la distribución de esta nueva variable "fecha_ancho" y nos damos cuenta de algo interesante:
```{r}
table(df$fecha_ancho)
```

Vemos picos claros en valores como '0' (exacta) y '99' (siglo), por esta razón decidimos crear una nueva variable llamada "fecha_cat" para captar mejor la estructura de la variable y mejorar la interpretación. Factorizamos y clasificamos en los siguientes niveles: '0' (fecha exacta), '1-10', (variabilidad baja), '11-98' (variabilidad moderada), '99' (grupo separado para fechas de siglo), '100+' (variabilidad alta).
```{r}
# grupos: 0, 1-10, 11-98, 99, +100
df$fecha_cat <- ifelse(df$fecha_ancho == 0, "0",
                        ifelse(df$fecha_ancho >= 1 & df$fecha_ancho <= 10, "1-10",
                        ifelse(df$fecha_ancho >= 11 & df$fecha_ancho <= 98, "11-98",
                        ifelse(df$fecha_ancho == 99, "99", "+100"))))

# Factor con niveles estables y ordenados
df$fecha_cat <- factor(
  df$fecha_cat,
  levels = c("0", "1-10", "11-98", "99", "+100"),
  ordered = TRUE
)

# comprobación
table(df$fecha_cat)
df$fecha_ancho <- NULL
```

**Recodificación de variable "procedencia"**

visualizarmeos algunos casos:
```{r}
head(df$procedencia)
tail(df$procedencia)
```

Podemos observar que no existe ningun tipo de estructura que nos sea de utilidad en esta variable, además simplemente aporta información de la posesión de la obra, no de su lugar de producción, por lo que no la consideramos una característica propia de esta. Decidimos prescindir de esta variable, no se transformará para ver utilizada pero se conservará en la base de datos como mera información consultable.

**Recodificación variable "titulo"**

Haremos uso de esta avriable para hacer una aproximación de la temática de cada obra utilizando sus palabras más frecuentes
```{r}
library(tm)

tit <- df$titulo
tit <- tolower(tit)

# quitar acentos
tit <- iconv(tit, from = "UTF-8", to = "ASCII//TRANSLIT")

# quitar puntuación, números y espacios extra
tit <- gsub("[[:punct:]]+", " ", tit)
tit <- gsub("[[:digit:]]+", " ", tit)
tit <- gsub("\\s+", " ", tit)

# tokenizar
palabras <- unlist(strsplit(tit, "\\s+"))

# quitar tokens vacíos y muy cortos
palabras <- palabras[nchar(palabras) >= 3]

# quitar stopwords
stop <- tm::stopwords("spanish")

palabras <- palabras[!(palabras %in% stop)]

# frecuencias
freq <- sort(table(palabras), decreasing = TRUE)
head(freq, 30)
```

La idea es crear un diccionario que almacene palabras clave de cada temática creada y asigne el tema correspondiente en la nueva variable "tema". Este proceso se ha repetido reiteradamente hasta lograr una clasificación satisfactoria, ya que en los primeros intentos un gran porcentaje de los casos caía en la categoría 'otros' por no ser clasificable. En cada iteración se obtubieron de nuevo las palabras más repetidas de este nivel 'otros' y se incluian en el diccionario para actualizarlo. Finalmente se ha aplicado el definitivo obteniendo las seguientes temáticas, con sus respectivas frecuencias:
```{r}
# normalizar
normaliza_texto <- function(x) {
  x <- tolower(x)
  x <- iconv(x, from = "UTF-8", to = "ASCII//TRANSLIT")
  x <- gsub("[[:punct:]]+", " ", x)
  x <- gsub("[[:digit:]]+", " ", x)
  x <- gsub("\\s+", " ", x)
  trimws(x)
}

titulo_norm <- normaliza_texto(df$titulo)

# temas
temas <- list(

  # 1) Religioso 
  religioso = c(
    "virgen","maria","senora","cristo","jesus",
    "san","santo","santa","santos",
    "crucifixion","calvario","descendimiento","piedad","dolorosa",
    "flagelacion","entierro","resurreccion","pentecostes","trinidad",
    "ecce","homo",                 
    "noli","tangere",              
    "adoracion","anunciacion","nacimiento","huida","aparicion",
    "inmaculada","concepcion",
    "bautista","magdalena","evangelista","pastores","magos",
    "angel(es)?","angeles",
    "cruz","martirio","penitente",
    "oracion","templo","ermita","iglesia","catedral","monasterio","misa","profeta", 
    "sagrada",
    "comunion","visitacion","natividad","ascension",
    "apostol(es)?","arcangel(es)?",
    "dios","alma","salvador",
    "virgen(es)?","pastor(es)?",
    "prodigo","parabola",
    "ultima cena",
    "adan","abraham","isaac","moises","david","salomon","jacob",
    "diluvio","paraiso","serpiente","caida","sacrificio",
    "judit","holofernes","susana", "cain","abel","sanson","tobias","rebeca","agar","eliezer"
  ),

  # 2) Mitología clásica / temas mitológicos
  mitologia = c(
    "diana","venus","hercules","apolo","mercurio","orfeo","cupido","adonis",
    "andromeda","ninfa(s)?","ninfas","vulcano","baco",
    "diosa","rapto","bacanal","bacanal","fabula","amorcillo(s)?","amorcillos", 
    "aquiles","eneas","atalanta","ceres","cefalo","ticio",
    "lucrecia","cleopatra",
    "armida"
  ),

  # 3) Retrato / corte / poder 
  retrato_corte = c(
    "autorretrato","retrato",
    "rey(es)?","reina","principe","infanta","infante",
    "duque","duquesa","conde","marques(a)?","cardenal",
    "caballero","dama","don",
    "emperador","ministro","papa","obispo",
    "borbon","austria","asturias","orleans",
    "felipe","carlos","isabel","fernando","alfonso","eugenia","catalina","mariana","juana","cristina","margarita", 
    "busto","sentado","desnudo",
    "artista","escritor","filosofo","escultor",
    "condesa"
  ),

  # 4) Historia / guerra / militar
  historia_alegoria = c(
    "batalla","combate","choque","soldado(s)?","soldados",
    "caballeria","conquista","victoria","triunfo",
    "naval","ultramar","expedicion",
    "alegoria","episodio","coronacion", 
    "guerra","general","convoy","patria","colon",
    "muerte","muerto(s)?","cadaver(es)?",
    "castidad","abundancia",
    "prision"
  ),

  # 5) Paisaje / lugares / naturaleza 
  paisaje_lugares = c(
    "paisaje","vista","marina","rio","puerto",
    "playa","costa","bosque","campo","agua(s)?","aguas","orilla(s)?","orillas",
    "laguna(s)?","lagunas","pico(s)?","picos",
    "invierno","primavera","otono",
    "jardin","interior","camino","ruinas","cercanias",
    "plaza","patio","palacio","castillo",
    "holanda","venecia","bruselas","granada","castilla","madrid","roma","toledo",
    "aragon","espana","francia","egipto","napoles","portugal","mexico","brasil",
    "alsasua","lequeitio","guethary","villerville","manzanares","retiro", 
    "mallorca","paris","sevilla","elche",
    "guadarrama","sierra","valle","alrededores",
    "torre"
  ),

  # 6) Vida cotidiana / costumbrismo
  vida_cotidiana = c(
    "escena","baile","fiesta","mercado",
    "fumador(es)?","fumadores",
    "merienda","musica","jugando","juego",
    "muchacho(s)?","muchachos","aldeano(s)?","aldeanos",
    "pueblo","real",       
    "bano","banquete","boda(s)?","bodas","boda", 
    "familia","madre","padre","hijo(s)?","hija(s)?","hermanos",
    "mujer(es)?","hombre(s)?","joven(es)?","nina(s)?","nino(s)?",
    "anciana(s)?","anciano(s)?","vieja(s)?","viejo(s)?",
    "maja(s)?","majo(s)?","manola","gitana","moro(s)?","veneciano(s)?","aldeana(s)?",
    "paseo","concierto","lectura","leyendo","leccion","jugador(es)?",
    "descanso","trabajo","vendedor(es)?","venta","carnaval","bebedor(es)?",
    "charlatan","bufon","ciego","despedida","pescador(es)?"
  ),

  # 7) Bodegón / floral 
  bodegon_floral = c(
    "bodegon","florero","flores","frutas","uvas","guirnalda","mesa","cocina","despensa",
    "flor(es)?","clavel(es)?","ciruela(s)?",
    "frutero","cantaro",
    "trampantojo","vanitas"
  ),

  # 8) Animales / caza 
  caza_animales = c(
    "caza","caceria","cazador",
    "caballo","perro(s)?","perros","perro",
    "oveja(s)?","ovejas","animal(es)?","animales","toros","aves",
    "rebano","gallinero","cazadores"
  ),

  # 9) Proceso / estudio / técnica
  proceso_obra = c(
    "copia","estudio","boceto","pintor",
    "figura(s)?","figuras","cabeza",
    "mural","triptico","perspectiva","decoracion"
  )
)

# clasificar (según primera coincidencia)
asigna_tema <- function(txt) {
  if (is.na(txt) || !nzchar(txt)) return("otros")
  for (tema in names(temas)) {
    for (kw in temas[[tema]]) {
      patron <- paste0("\\b", kw, "\\b")
      if (grepl(patron, txt, perl = TRUE)) return(tema)
    }
  }
  "otros"
}

df$tema <- vapply(titulo_norm, asigna_tema, character(1))

df$tema <- as.factor(df$tema)

# frecuencias
sort(table(df$tema), decreasing = TRUE)
```

**Variables no analizables**

Finalmente listamos las variables que se han conservado en la abse de datos a modo de posibles consultas futuras, pero que no participaran de ningun modo en el analisis: "numero_catalalogo", "titulo", "url", "nombre_autor", "procedencia", "fecha".

## CREACIÓN DE NUEVAS VARIABLES

En la sección anterior hemos transformado y también creado algunas variable con el fin único de reestructurar la información ya presente. Sin embargo, en esta sección podrecederemos a de alguna manera "generar" nueva información, que consideramos de posible utilidad, a partir de la que ya disponemos. 

**Variable respuesta**

Para comenzar generaremos nuestra variabe objetivo dele studio que es aquella relacionada con la proporción aurea. Haremos uso de las variables de dimension "alto" y "ancho" para crear la que será nuestra avriable respuesta llamada "exito". Esta será un indicador binaria que determinará si la pintura sigue o no la proporción aurea. El error aceptado es del 5% y en todo momento se utiliza el largo largo como numerador.
```{r}
# convertir dimensiones a numerico
df$alto  <- as.numeric(gsub(",", ".", df$alto,  fixed = TRUE))
df$ancho <- as.numeric(gsub(",", ".", df$ancho, fixed = TRUE))

# razón de aspecto: lado más largo / lado más corto
lado_largo <- pmax(df$alto, df$ancho)
lado_corto <- pmin(df$alto, df$ancho)

df$razon <- lado_largo / lado_corto   

# indicador razón aurea (éxitos)
phi <- (1 + sqrt(5)) / 2
tol <- 0.05 * phi

df$exito <- as.integer(abs(df$razon - phi) <= tol)
df$exito <- as.factor(df$exito)

str(df$exito)
```

**Variable "orientacion"**

A partir de las variables de dimensión "alto" y "ancho" creamos una nueva variable que nos indique si la forma de la pintura es vertical, horizontal o cuadrada.
```{r}
# orientación: vertical si alto > ancho, horizontal si ancho > alto
df$orientacion <- ifelse(df$alto > df$ancho, "vertical",
                         ifelse(df$ancho > df$alto, "horizontal", "cuadrado"))
df$orientacion <- as.factor(df$orientacion)

table(df$orientacion)
```

**Variables "area" y "tam_cat"**

También trabajamos con las dimensiones para crear 2 variables relacionadas con el tamaño: "area", para conocer su superficie, y "tam_cat" para clasificarlas en categorías de tamaño "pequeño/mediano/grande".
```{r}
df$area <- df$alto * df$ancho

# categorías de tamaño por cuantiles (opcional)
qs <- quantile(df$area, probs = c(0.33, 0.66), na.rm=TRUE)
df$tam_cat <- cut(df$area, breaks = c(-Inf, qs[1], qs[2], Inf),
                  labels = c("pequeno","mediano","grande"), right = TRUE)

df$tam_cat <- factor(
  df$tam_cat,
  levels = c("pequeno","mediano","grande"),
  ordered = TRUE
)

df$tam_cat <- as.factor(df$tam_cat)
```

## Manejo de desvalances

Presentaremos las frecuencias de cada variable factor:
```{r}
cat <- c(
  "tam_cat",
  "orientacion",
  "soporte_grp",
  "sop_montaje",
  "tecnica",
  "tipo_autor",
  "serie",
  "fecha_cat",
  "tema"
)

for (v in cat) {
  cat("\n====================\n")
  cat("Variable:", v, "\n")
  print(table(df[[v]]))
}
```

Para detectar roblemas reales debemos fijarnos no en el conteo marginal, sino cruzado con la variable objetivo. Fijaremos como indicio de problema cuando el recuento de "exito"='1' sea inferior a 5 en una categoría.
```{r}
y <- df$exito  

for (v in cat) {
  tab2 <- table(y, df[[v]])
  m <- min(tab2)
  if (m < 5) {  # umbral típico para problemas
    cat("\n*** POSIBLE PROBLEMA (min celda <", 5, ") en:", v, "***\n")
    print(tab2)
  }
}
```

Vemos que las únicas variables realmente problematicas son "orientacion" con el nivel 'cuadrado', "soporte_grp" con el nivel 'otros' y "tecnica" con los niveles 'acuosas', 'fresco' y 'otras'. 

Comenzando con "orientación" podemos ver que es obvio el hecho de que en el nivel 'cuadrado' no va a aparecer ningún éxito por definición: si es cuadrado es imposible que siga la proporción aurea. No podemso simplemente eliminar estos casos, aunque sean pocos, porque estariamos generando un sesgo sistemático, pero lo que sí haremos será aplicar esta regla en el ajuste. Es decir, los cuadrados siempre serán catalogados como exito=0 y las interpretaciones se haran teniendo en cuenta la modificación en la inferencia, solo podremos inferir en aquellas obras no cuadradas.

Las dos otras variables se solucionarán simplemente reagrupando sus niveles. Para "soporte_grp" reagruparemos 'Papel/Vitela' en 'Otros', y para "tecnica" reagruparemos únicamente en 'oleo', 'mixta' y 'otras'.
```{r}
# soporte_grp: mover "Papel/Vitela" a "Otros"
df$soporte_grp <- as.character(df$soporte_grp)
df$soporte_grp[df$soporte_grp == "Papel/Vitela"] <- "Otros"
df$soporte_grp <- factor(df$soporte_grp)

# tecnica: dejar solo "oleo", "mixta" y "otras"
df$tecnica <- as.character(df$tecnica)
df$tecnica[!(df$tecnica %in% c("oleo", "mixta"))] <- "otras"
df$tecnica <- factor(df$tecnica)

# comprobar
cat("\n====================\n")
cat("Frecuencias margincales:")
table(df$soporte_grp)
table(df$tecnica)
cat("\n====================\n")
cat("Frecuencias cruzadas:")
table(df$exito, df$soporte_grp)
table(df$exito, df$tecnica)
```

# BASE DE DATOS FINAL 

Finalmente obtenemos la base de datos ya tratada ('df_completa') y una extracción solo con las variables útiles para el análisis ('df')
```{r}
df_completa <- df[, c(
 
  # no útiles
  "numero_catalogo",
  "titulo",
  "url",
  "nombre_autor",
  "procedencia",
  "fecha",
  "alto",
  "ancho",
 
  # útiles
  "exito",
  "razon",
  "area",
  "tam_cat",
  "orientacion",
  "soporte",
  "soporte_grp",
  "sop_montaje",
  "tecnica",
  "tipo_autor",
  "serie",
  "fecha_est",
  "fecha_cat",
  "tema"
)]

df <- df[, c(
  "exito",
  "razon",
  "area",
  "tam_cat",
  "orientacion",
  "soporte_grp",
  "sop_montaje",
  "tecnica",
  "tipo_autor",
  "serie",
  "fecha_est",
  "fecha_cat",
  "tema"
)]

str(df_completa); str(df)

# para exportar los archivos:
write.csv(df_completa, "prado_gestionado.csv", row.names = FALSE)
write.csv(df, "prado_variables.csv", row.names = FALSE)
```
